# -*- coding: utf-8 -*-
"""Retail Demand Forecaster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1au-cA_tgmsbyOCHmC7k4uYdCUAdooszJ
"""

#BLOCK 1 — Install & upgrade libraries (IMPORTANT)
pip install -q -U datasets huggingface_hub pandas numpy matplotlib scikit-learn prophet

#BLOCK 2 — Imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from datasets import load_dataset
from sklearn.metrics import mean_absolute_error

#BLOCK 3 — Load the WORKING dataset
ds = load_dataset("t4tiana/store-sales-time-series-forecasting")
print(ds)

#BLOCK 4 — Load train split safely
df = ds["train"].to_pandas()

print(df.shape)
print(df.columns)
df.head()

#BLOCK 5 — Clean & standardize columns
df["date"] = pd.to_datetime(df["date"])

df = df.rename(columns={
    "store_nbr": "store_id",
    "family": "item_id",
    "sales": "y"
})

df["series_id"] = df["store_id"].astype(str) + "_" + df["item_id"].astype(str)

df = df.sort_values(["series_id", "date"]).reset_index(drop=True)

df.head()

#BLOCK 6 — Create time index
df["t"] = df.groupby("series_id").cumcount()
df[["series_id", "date", "t", "y"]].head()

#BLOCK 7 — Train / validation split (last 28 days per series)
H = 28

train_rows = []
val_rows = []

for sid, g in df.groupby("series_id"):
    if len(g) <= H:
        continue
    train_rows.append(g.iloc[:-H])
    val_rows.append(g.iloc[-H:])

train_df = pd.concat(train_rows)
val_df   = pd.concat(val_rows)

print(train_df.shape, val_df.shape)

#PART 1 — Prophet with Uncertainty (P50 / P90)
# BLOCK 8 — Prophet forecasting function
from prophet import Prophet

def prophet_with_uncertainty(train_df, val_df, max_series=50):
    outputs = []
    series_list = train_df["series_id"].unique()[:max_series]

    for sid in series_list:
        tr = train_df[train_df["series_id"] == sid]
        va = val_df[val_df["series_id"] == sid]

        m = Prophet(weekly_seasonality=True, yearly_seasonality=True)
        m.fit(tr.rename(columns={"date": "ds"})[["ds", "y"]])

        future = va.rename(columns={"date": "ds"})[["ds"]]
        fcst = m.predict(future)

        outputs.append(pd.DataFrame({
            "series_id": sid,
            "y_true": va["y"].values,
            "p50": np.clip(fcst["yhat"].values, 0, None),
            "p90": np.clip(fcst["yhat_upper"].values, 0, None),
        }))

    return pd.concat(outputs, ignore_index=True)

#BLOCK 9 — Run Prophet + check accuracy
prophet_val = prophet_with_uncertainty(train_df, val_df, max_series=50)

print("MAE (P50):",
      mean_absolute_error(prophet_val["y_true"], prophet_val["p50"]))

#PART 2 — Inventory & Cost Simulation (THE REAL VALUE)
# BLOCK 10 — Inventory simulation function
def simulate_inventory_costs(
    demand,
    forecast,
    lead_time=7,
    holding_cost=1.0,
    stockout_cost=10.0
):
    inventory = 0.0
    pipeline = [0.0] * lead_time

    holding_total = 0.0
    stockout_total = 0.0
    stockout_events = 0

    for d, f in zip(demand, forecast):
        inventory += pipeline.pop(0)

        if d > inventory:
            unmet = d - inventory
            stockout_total += unmet * stockout_cost
            inventory = 0
            stockout_events += 1
        else:
            inventory -= d

        holding_total += inventory * holding_cost

        target = lead_time * f
        order_qty = max(target - (inventory + sum(pipeline)), 0)
        pipeline.append(order_qty)

    return {
        "total_cost": holding_total + stockout_total,
        "holding_cost": holding_total,
        "stockout_cost": stockout_total,
        "stockout_events": stockout_events
    }

#BLOCK 11 — Compare P50 vs P90 (SERVICE LEVEL LOGIC)
res_p50 = simulate_inventory_costs(
    prophet_val["y_true"].values,
    prophet_val["p50"].values
)

res_p90 = simulate_inventory_costs(
    prophet_val["y_true"].values,
    prophet_val["p90"].values
)

res_p50, res_p90

#BLOCK 12 — Business impact summary
def print_summary(name, res):
    print(f"\n{name}")
    print("Total cost:     ", round(res["total_cost"], 2))
    print("Holding cost:   ", round(res["holding_cost"], 2))
    print("Stockout cost:  ", round(res["stockout_cost"], 2))
    print("Stockout events:", res["stockout_events"])

print_summary("Prophet P50", res_p50)
print_summary("Prophet P90 (Service-Level)", res_p90)

print("\nStockout reduction (%):",
      (res_p50["stockout_events"] - res_p90["stockout_events"])
      / max(res_p50["stockout_events"], 1) * 100)

#BLOCK 13 — Visual sanity check (optional but recommended)
N = 200

plt.figure(figsize=(10,4))
plt.plot(prophet_val["y_true"].values[:N], label="Actual")
plt.plot(prophet_val["p50"].values[:N], label="P50 forecast")
plt.plot(prophet_val["p90"].values[:N], label="P90 forecast")
plt.legend()
plt.title("Demand Forecast with Uncertainty")
plt.show()